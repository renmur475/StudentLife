# Implementation Manual
## App
The main class, App, is the home screen and extends Application. In the “start” method, the layout is made with a BorderPane, StackPane, and GridPane for alignment. The title is placed in a StackPane and is aligned at the top of the BorderPane. The “apps” are comprised of images and buttons that are placed in a GridPane aligned in the center of the BorderPane. The images use ImageView to locate and display the correct images. When a button is pressed, the setOnAction uses a lambda expression to call the method where the new scene is located in that class. The mainDisplay method allows the other classes to call the method and switch back to the home screen. The main method launches the app.
## Notes
In the “Notes” class, various panes are used to create and align the layout. The “Open” button allows the user to open a .txt file from their computer. Once the user selects a file, it is displayed in the TextArea. This is done using setOnAction and a lambda expression that calls the fileOpen method. The fileOpen method uses FileChooser to open the file explorer. Then, the scanner checks for text in the file and appends it to the TextArea. The “Save” button allows the user to save the text they wrote in the TextArea to a new file on their computer. This is done using setOnAction and a lambda expression that calls the fileSave method. The fileSave method uses FileChooser to open the file explorer where the user can save the file. Then, the PrintWriter writes the text from the TextArea to a .txt file. The “Home” button runs the mainDisplay method in the “App” class to return to the home screen.
## Flashcards
In the “Flashcards” class, various panes are used to create and align the layout. When the user presses the “Add” button, any text entered in the TextArea under the “Side 1” label will be stored in the first column of the String matrix “flashCards.” Any text entered under the “Side 2” label will be stored in the second column of the matrix. An array called “counter” is used to keep track of the flashcard number. If this is the first flashcard entered, both sides will be stored in row zero of the matrix. The counter will increase after the text has been added. Once the user has added all their flashcards, they can press the “Study” button. This runs the “study” method. A new window is created by setting a new stage and scene. Using “Random,” a random int is generated with the maximum number being the total flashcards created and stored in the counter. This random number determines which flashcard will be displayed which is represented by the row of the matrix. The text from the front side, column 0, will be shown in the TextArea by default. When the user presses the “Flip” button, the column changes to 1. This is done by checking if the current text shown in the TextArea is equal to the text on the first side. If it is true, then the text is set to the second side. If it is false, then the text is set to the first side. When the user presses the “Next” button, a new random number will be generated to represent the row of the next flashcard. Side 1 of that flashcard will be displayed in the TextArea. The user can close the window to return to the app. The “Home” button runs the mainDisplay method in the “App” class to return to the home screen.
## Calendar
In the "Calendar" class, nodes are declared as well as an ObservableList to populate the table. In the "start" class the table is created with three columns, the Assignment Name, Due Date, and Done columns. Each column is associated with their corresponding properties of name and date. The done column adds a checkbox to it. Various table settings are declared, like the size and sorting of columns. The user input fields, "enterName" and "chooseDate" are created, as well as the "hide" and "add" buttons. These nodes are added to their containers, and then the stage. The "Assignment" class creates the data model for the table. It has a constructor class of the same name to initalize the properties of the table as well. Each property has a getter that returns the value of the property, or setter which sets the property to the users input. The "handle" class is where all the action events are. For the add button, a new Assignment is added by getting the input from enterName and the value from chooseDate. It adds it to the table when clicked. For the hide button, an ObservableList "toHide" is created for the assignments that are to be hidden. It enters a for loop that traverses each row, if the checkbox is checked it will return true and the assginment to "toHide". Then, all rows in "toHide" are removed. 
## Calculator
In the "Calculator" class, the button arrays "numButtons" and "functionButtons" , all function buttons, and the home button is declared. The text field resultField is declared, which displays the numbers and results. Finally, variables to store the inputs, results, and the operator used are declared. In the "start" class, a GridPane layout is created to house all nodes. Using ColumnConstraints and RowRestraints, a 4x6 grid of 100x100 squares is created. "resultField" is setEditable to false so it cannot be modified. Function buttons are labeled, and then added to the "funcButtons" array for easy access. The first for loop sets an action when clicked on each function button and states their size. The second for loop creates the number buttons and labels them depending on the index the loop is at. It also sets their size and action when clicked. All buttons are added to the grid. The home button when clicked will take you back to the main home screen. The "handle" class contains all button actions. When a number button is clicked, it will set the resultField to that number. When any function button is clicked, it will store the previously inputted number as input1 and set the operator to its corresponding operator. When the negative button is clicked, it will store the input as "negative" and multiply it by -1. When the decimal button is clicked, it will add a decimal to the resultField using concat. The clr button will set resultField to an empty space. The delete button will enter a for loop that prints out everything shown on the resultField except for the last character. Finally, when the equals button is clicked it enters a switch statement. Depending on the operator, it will store the latest input as input2 and do the corresponding function. 
